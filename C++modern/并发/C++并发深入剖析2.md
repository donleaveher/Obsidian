## 1. 总述

本文档基于LLVM的libc++库实现，剖析future里实现的C++11异步机制的源码。

### 1.1 关键组件

1. **共享状态基类**：
   - `__assoc_sub_state`：所有共享状态的基类，继承自`__shared_count`
   - `__assoc_state<_Rp>`：带类型的共享状态，存储具体的返回值

2. **异步执行状态类**：
   - `__deferred_assoc_state`：延迟执行状态
   - `__async_assoc_state`：异步执行状态

3. **用户接口类**：
   - `std::future<T>`：异步结果的获取接口
   - `std::promise<T>`：异步结果的设置接口
   - `std::packaged_task<T>`：可调用对象的包装器
   - `std::async`：异步执行函数

### 1.2 组件功能

- **`__assoc_sub_state`**：提供基础的同步机制（mutex、condition_variable）和引用计数管理
- **`__assoc_state<_Rp>`**：在基类基础上添加类型化的值存储和操作
- **`std::future`**：提供异步结果的只读访问接口
- **`std::promise`**：提供异步结果的写入接口
- **`std::packaged_task`**：将可调用对象包装成异步任务
- **`std::async`**：提供便捷的异步执行入口

### 1.3 组件交互关系

```
┌─────────────────┐    ┌─────────────────┐
│   std::future   │◄───┤  std::promise   │
└─────────────────┘    └─────────────────┘
         │                       │
         └───────────┬───────────┘
                     ▼
            ┌─────────────────┐
            │ __assoc_state   │
            └─────────────────┘
                     │
                     ▼
            ┌─────────────────┐
            │__assoc_sub_state│
            └─────────────────┘
                     │
                     ▼
            ┌─────────────────┐
            │ __shared_count  │
            └─────────────────┘
```

## 2. 组件与共享状态的关系

### 2.1 共享状态的拥有关系

- **`std::future`**：不拥有共享状态，只是持有指针引用
- **`std::promise`**：拥有共享状态，在构造时创建
- **`std::packaged_task`**：内部包含一个`promise`，间接拥有共享状态

### 2.2 共享状态的传递

共享状态通过以下方式在组件间传递：
1. `promise.get_future()`：将共享状态传递给future
2. `packaged_task.get_future()`：通过内部promise传递
3. `std::async`：创建特殊的异步状态并返回future

## 3. 共享状态的生命周期

### 3.1 引用计数机制

共享状态类的生命周期通过引用计数来决定。引用计数的目的是确保在所有相关的future和promise对象都销毁之前，共享状态不会被释放，从而保证异步操作的安全性。

**计数规则**：
- **计数+1的时机**：
  - future对象构造时调用`__attach_future()`
  - shared_future拷贝构造时调用`__add_shared()`
  - promise构造时隐式+1（作为初始引用）

- **计数-1的时机**：
  - future对象析构时调用`__release_shared()`
  - promise对象析构时调用`__release_shared()`
  - shared_future析构时调用`__release_shared()`

### 3.2 共享状态创建（核心源码）

```cpp
// promise构造时创建共享状态
template <class _Rp>
promise<_Rp>::promise() : __state_(new __assoc_state<_Rp>) {
    // 创建新的关联状态对象
    // __assoc_state继承自__assoc_sub_state，后者继承自__shared_count
    // 初始引用计数为1
}

// future构造时附加到共享状态
template <class _Rp>
future<_Rp>::future(__assoc_state<_Rp>* __state) : __state_(__state) {
    __state_->__attach_future(); // 增加引用计数，标记future已附加
}

// __attach_future的实现
void __assoc_sub_state::__attach_future() {
    lock_guard<mutex> __lk(__mut_);
    bool __has_future_attached = (__state_ & __future_attached) != 0;
    if (__has_future_attached)
        std::__throw_future_error(future_errc::future_already_retrieved);
    this->__add_shared(); // 增加引用计数
    __state_ |= __future_attached; // 设置future已附加标志
}
```

### 3.3 共享状态销毁（核心源码）

```cpp
// future析构时释放共享状态
template <class _Rp>
future<_Rp>::~future() {
    if (__state_)
        __state_->__release_shared(); // 减少引用计数
}

// promise析构时的处理
template <class _Rp>
promise<_Rp>::~promise() {
    if (__state_) {
        // 如果promise被销毁时还没有设置值，且还有future在等待
        if (!__state_->__has_value() && __state_->use_count() > 1)
            __state_->set_exception(make_exception_ptr(
                future_error(make_error_code(future_errc::broken_promise))));
        __state_->__release_shared(); // 减少引用计数
    }
}

// 当引用计数归零时的清理
template <class _Rp>
void __assoc_state<_Rp>::__on_zero_shared() _NOEXCEPT {
    if (this->__state_ & base::__constructed)
        reinterpret_cast<_Rp*>(std::addressof(__value_))->~_Rp(); // 销毁存储的值
    delete this; // 删除共享状态对象
}
```

## 4. 核心组件源码解析

### 4.1 __assoc_sub_state实现

`__assoc_sub_state`是所有共享状态的基类，提供基础的同步和状态管理功能。

```cpp
class _LIBCPP_EXPORTED_FROM_ABI __assoc_sub_state : public __shared_count {
protected:
    exception_ptr __exception_;           // 存储异常
    mutable mutex __mut_;                 // 互斥锁，保护状态访问
    mutable condition_variable __cv_;     // 条件变量，用于等待通知
    unsigned __state_;                    // 状态标志位

    void __on_zero_shared() _NOEXCEPT override; // 引用计数归零时调用
    void __sub_wait(unique_lock<mutex>& __lk);   // 内部等待实现

public:
    // 状态标志常量
    enum { 
        __constructed = 1,      // 值已构造
        __future_attached = 2,  // future已附加
        ready = 4,             // 结果已就绪
        deferred = 8           // 延迟执行
    };

    // 构造函数：初始化状态为0
    _LIBCPP_HIDE_FROM_ABI __assoc_sub_state() : __state_(0) {}

    // 检查是否有值（已构造或有异常）
    _LIBCPP_HIDE_FROM_ABI bool __has_value() const { 
        return (__state_ & __constructed) || (__exception_ != nullptr); 
    }

    // 附加future，增加引用计数并设置标志
    _LIBCPP_HIDE_FROM_ABI void __attach_future() {
        lock_guard<mutex> __lk(__mut_);
        bool __has_future_attached = (__state_ & __future_attached) != 0;
        if (__has_future_attached)
            std::__throw_future_error(future_errc::future_already_retrieved);
        this->__add_shared(); // 增加引用计数
        __state_ |= __future_attached;
    }

    // 设置延迟执行标志
    _LIBCPP_HIDE_FROM_ABI void __set_deferred() { __state_ |= deferred; }

    // 检查是否就绪
    _LIBCPP_HIDE_FROM_ABI bool __is_ready() const { return (__state_ & ready) != 0; }

    // 等待结果就绪
    void wait();
    
    // 带超时的等待
    template <class _Rep, class _Period>
    future_status wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const;
    
    template <class _Clock, class _Duration>
    future_status wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const {
        unique_lock<mutex> __lk(__mut_);
        if (__state_ & deferred)
            return future_status::deferred;
        while (!(__state_ & ready) && _Clock::now() < __abs_time)
            __cv_.wait_until(__lk, __abs_time);
        if (__state_ & ready)
            return future_status::ready;
        return future_status::timeout;
    }

    // 虚函数，用于延迟执行
    virtual void __execute();
};
```

### 4.2 __assoc_state实现

`__assoc_state<_Rp>`继承自`__assoc_sub_state`，添加了类型化的值存储功能。

```cpp
template <class _Rp>
class _LIBCPP_HIDDEN __assoc_state : public __assoc_sub_state {
    typedef __assoc_sub_state base;
    // 使用aligned_storage存储值，确保正确的内存对齐
    typedef typename aligned_storage<sizeof(_Rp), _LIBCPP_ALIGNOF(_Rp)>::type _Up;

protected:
    _Up __value_; // 存储实际的值

    // 引用计数归零时的清理
    _LIBCPP_HIDE_FROM_ABI_VIRTUAL void __on_zero_shared() _NOEXCEPT override;

public:
    // 设置值（支持完美转发）
    template <class _Arg>
    _LIBCPP_HIDE_FROM_ABI void set_value(_Arg&& __arg);
    
    // 在线程退出时设置值
    template <class _Arg>
    _LIBCPP_HIDE_FROM_ABI void set_value_at_thread_exit(_Arg&& __arg);

    // 移动语义获取值
    _LIBCPP_HIDE_FROM_ABI _Rp move();
    // 拷贝语义获取值
    _LIBCPP_HIDE_FROM_ABI _Rp& copy();
};

// set_value的实现
template <class _Rp>
template <class _Arg>
void __assoc_state<_Rp>::set_value(_Arg&& __arg) {
    unique_lock<mutex> __lk(this->__mut_);
    if (this->__has_value())
        std::__throw_future_error(future_errc::promise_already_satisfied);
    // 使用placement new在预分配的内存中构造对象
    ::new ((void*)std::addressof(__value_)) _Rp(std::forward<_Arg>(__arg));
    this->__state_ |= base::__constructed | base::ready; // 设置状态标志
    __cv_.notify_all(); // 通知所有等待的线程
}

// move方法的实现
template <class _Rp>
_Rp __assoc_state<_Rp>::move() {
    unique_lock<mutex> __lk(this->__mut_);
    this->__sub_wait(__lk); // 等待结果就绪
    if (this->__exception_ != nullptr)
        std::rethrow_exception(this->__exception_); // 重新抛出异常
    return std::move(*reinterpret_cast<_Rp*>(std::addressof(__value_)));
}
```

### 4.3 std::future实现

`std::future`提供异步结果的只读访问接口，是移动语义的。

```cpp
template <class _Rp>
class future {
    __assoc_state<_Rp>* __state_; // 指向共享状态的指针

    // 私有构造函数，只能通过promise或async创建
    explicit _LIBCPP_HIDE_FROM_ABI future(__assoc_state<_Rp>* __state);

    // 友元声明，允许promise和相关函数访问私有构造函数
    template <class> friend class promise;
    template <class> friend class shared_future;
    template <class _R1, class _Fp>
    friend future<_R1> __make_deferred_assoc_state(_Fp&& __f);
    template <class _R1, class _Fp>
    friend future<_R1> __make_async_assoc_state(_Fp&& __f);

public:
    // 默认构造函数：创建无效的future
    _LIBCPP_HIDE_FROM_ABI future() _NOEXCEPT : __state_(nullptr) {}
    
    // 移动构造函数
    _LIBCPP_HIDE_FROM_ABI future(future&& __rhs) _NOEXCEPT 
        : __state_(__rhs.__state_) { 
        __rhs.__state_ = nullptr; 
    }
    
    // 禁用拷贝构造和拷贝赋值
    future(const future&) = delete;
    future& operator=(const future&) = delete;
    
    // 移动赋值操作符
    _LIBCPP_HIDE_FROM_ABI future& operator=(future&& __rhs) _NOEXCEPT {
        future(std::move(__rhs)).swap(*this);
        return *this;
    }

    // 析构函数：释放共享状态引用
    _LIBCPP_HIDE_FROM_ABI ~future();
    
    // 转换为shared_future
    _LIBCPP_HIDE_FROM_ABI shared_future<_Rp> share() _NOEXCEPT;

    // 获取结果（只能调用一次）
    _LIBCPP_HIDE_FROM_ABI _Rp get();

    // 交换两个future
    _LIBCPP_HIDE_FROM_ABI void swap(future& __rhs) _NOEXCEPT { 
        std::swap(__state_, __rhs.__state_); 
    }

    // 检查future是否有效
    _LIBCPP_HIDE_FROM_ABI bool valid() const _NOEXCEPT { 
        return __state_ != nullptr; 
    }

    // 等待结果就绪
    _LIBCPP_HIDE_FROM_ABI void wait() const { __state_->wait(); }
    
    // 带超时的等待
    template <class _Rep, class _Period>
    _LIBCPP_HIDE_FROM_ABI future_status wait_for(
        const chrono::duration<_Rep, _Period>& __rel_time) const {
        return __state_->wait_for(__rel_time);
    }
    
    template <class _Clock, class _Duration>
    _LIBCPP_HIDE_FROM_ABI future_status wait_until(
        const chrono::time_point<_Clock, _Duration>& __abs_time) const {
        return __state_->wait_until(__abs_time);
    }
};

// future构造函数实现
template <class _Rp>
future<_Rp>::future(__assoc_state<_Rp>* __state) : __state_(__state) {
    __state_->__attach_future(); // 附加future并增加引用计数
}

// future析构函数实现
template <class _Rp>
future<_Rp>::~future() {
    if (__state_)
        __state_->__release_shared(); // 释放共享状态引用
}

// get方法实现
template <class _Rp>
_Rp future<_Rp>::get() {
    // 使用RAII确保状态被正确释放
    unique_ptr<__shared_count, __release_shared_count> __guard(__state_);
    __assoc_state<_Rp>* __s = __state_;
    __state_ = nullptr; // 清空状态指针，确保只能get一次
    return __s->move(); // 移动语义返回结果
}
```

### 4.4 std::promise实现

`std::promise`提供设置异步结果的接口，与future配对使用。

```cpp
template <class _Rp>
class promise {
    __assoc_state<_Rp>* __state_; // 指向共享状态的指针

    // 私有构造函数，用于创建无效的promise
    _LIBCPP_HIDE_FROM_ABI explicit promise(nullptr_t) _NOEXCEPT : __state_(nullptr) {}

    template <class> friend class packaged_task; // 友元声明

public:
    // 默认构造函数：创建新的共享状态
    _LIBCPP_HIDE_FROM_ABI promise();
    
    // 带分配器的构造函数
    template <class _Alloc>
    _LIBCPP_HIDE_FROM_ABI promise(allocator_arg_t, const _Alloc& __a);
    
    // 移动构造函数
    _LIBCPP_HIDE_FROM_ABI promise(promise&& __rhs) _NOEXCEPT 
        : __state_(__rhs.__state_) { 
        __rhs.__state_ = nullptr; 
    }
    
    // 禁用拷贝构造
    promise(const promise& __rhs) = delete;
    
    // 析构函数
    _LIBCPP_HIDE_FROM_ABI ~promise();

    // 移动赋值操作符
    _LIBCPP_HIDE_FROM_ABI promise& operator=(promise&& __rhs) _NOEXCEPT {
        promise(std::move(__rhs)).swap(*this);
        return *this;
    }
    
    // 禁用拷贝赋值
    promise& operator=(const promise& __rhs) = delete;

    // 交换两个promise
    _LIBCPP_HIDE_FROM_ABI void swap(promise& __rhs) _NOEXCEPT { 
        std::swap(__state_, __rhs.__state_); 
    }

    // 获取关联的future
    _LIBCPP_HIDE_FROM_ABI future<_Rp> get_future();

    // 设置值的方法
    _LIBCPP_HIDE_FROM_ABI void set_value(const _Rp& __r);
    _LIBCPP_HIDE_FROM_ABI void set_value(_Rp&& __r);
    _LIBCPP_HIDE_FROM_ABI void set_exception(exception_ptr __p);

    // 在线程退出时设置值的方法
    _LIBCPP_HIDE_FROM_ABI void set_value_at_thread_exit(const _Rp& __r);
    _LIBCPP_HIDE_FROM_ABI void set_value_at_thread_exit(_Rp&& __r);
    _LIBCPP_HIDE_FROM_ABI void set_exception_at_thread_exit(exception_ptr __p);
};

// promise默认构造函数实现
template <class _Rp>
promise<_Rp>::promise() : __state_(new __assoc_state<_Rp>) {
    // 创建新的关联状态，初始引用计数为1
}

// promise析构函数实现
template <class _Rp>
promise<_Rp>::~promise() {
    if (__state_) {
        // 如果promise被销毁时还没有设置值，且还有future在等待
        // 则设置broken_promise异常
        if (!__state_->__has_value() && __state_->use_count() > 1)
            __state_->set_exception(make_exception_ptr(
                future_error(make_error_code(future_errc::broken_promise))));
        __state_->__release_shared(); // 释放共享状态引用
    }
}

// get_future方法实现
template <class _Rp>
future<_Rp> promise<_Rp>::get_future() {
    if (__state_ == nullptr)
        std::__throw_future_error(future_errc::no_state);
    return future<_Rp>(__state_); // 创建关联的future
}

// set_value方法实现
template <class _Rp>
void promise<_Rp>::set_value(const _Rp& __r) {
    if (__state_ == nullptr)
        std::__throw_future_error(future_errc::no_state);
    __state_->set_value(__r); // 委托给共享状态
}

template <class _Rp>
void promise<_Rp>::set_value(_Rp&& __r) {
    if (__state_ == nullptr)
        std::__throw_future_error(future_errc::no_state);
    __state_->set_value(std::move(__r)); // 移动语义设置值
}
```

### 4.5 promise与future的关联机制

promise和future通过共享状态进行关联，这种关联是在`promise::get_future()`调用时建立的：

```cpp
// promise创建future的过程
template <class _Rp>
future<_Rp> promise<_Rp>::get_future() {
    if (__state_ == nullptr)
        std::__throw_future_error(future_errc::no_state);
    // 将promise的共享状态传递给future
    // future构造函数会调用__attach_future()增加引用计数
    return future<_Rp>(__state_);
}

// future构造时的关联过程
template <class _Rp>
future<_Rp>::future(__assoc_state<_Rp>* __state) : __state_(__state) {
    __state_->__attach_future(); // 建立关联并增加引用计数
}

// __attach_future的实现确保一个promise只能创建一个future
void __assoc_sub_state::__attach_future() {
    lock_guard<mutex> __lk(__mut_);
    bool __has_future_attached = (__state_ & __future_attached) != 0;
    if (__has_future_attached)
        std::__throw_future_error(future_errc::future_already_retrieved);
    this->__add_shared(); // 增加引用计数
    __state_ |= __future_attached; // 设置future已附加标志
}
```

### 4.6 __packaged_task_function和std::packaged_task实现

`std::packaged_task`将可调用对象包装成异步任务，内部使用`__packaged_task_function`进行类型擦除。

```cpp
// std::packaged_task的实现
template <class _Rp, class... _ArgTypes>
class packaged_task<_Rp(_ArgTypes...)> {
public:
    using result_type = _Rp; // 结果类型

private:
    __packaged_task_function<_Rp(_ArgTypes...)> __f_; // 包装的可调用对象
    promise<_Rp> __p_; // 内部promise对象

public:
    // 默认构造函数：创建无效的packaged_task
    _LIBCPP_HIDE_FROM_ABI packaged_task() _NOEXCEPT : __p_(nullptr) {}

    // 从可调用对象构造
    template <class _Fp, __enable_if_t<!is_same<__remove_cvref_t<_Fp>, packaged_task>::value, int> = 0>
    _LIBCPP_HIDE_FROM_ABI explicit packaged_task(_Fp&& __f) 
        : __f_(std::forward<_Fp>(__f)) {}

    // 禁用拷贝
    packaged_task(const packaged_task&) = delete;
    packaged_task& operator=(const packaged_task&) = delete;

    // 移动构造和赋值
    _LIBCPP_HIDE_FROM_ABI packaged_task(packaged_task&& __other) _NOEXCEPT
        : __f_(std::move(__other.__f_)), __p_(std::move(__other.__p_)) {}
        
    _LIBCPP_HIDE_FROM_ABI packaged_task& operator=(packaged_task&& __other) _NOEXCEPT {
        __f_ = std::move(__other.__f_);
        __p_ = std::move(__other.__p_);
        return *this;
    }
    
    // 交换函数
    _LIBCPP_HIDE_FROM_ABI void swap(packaged_task& __other) _NOEXCEPT {
        __f_.swap(__other.__f_);
        __p_.swap(__other.__p_);
    }

    // 检查是否有效
    _LIBCPP_HIDE_FROM_ABI bool valid() const _NOEXCEPT { 
        return __p_.__state_ != nullptr; 
    }

    // 获取关联的future
    _LIBCPP_HIDE_FROM_ABI future<_Rp> get_future() { 
        return __p_.get_future(); 
    }

    // 执行任务
    _LIBCPP_HIDE_FROM_ABI void operator()(_ArgTypes... __args);
    
    // 在线程退出时执行任务
    _LIBCPP_HIDE_FROM_ABI void make_ready_at_thread_exit(_ArgTypes... __args);

    // 重置任务状态
    _LIBCPP_HIDE_FROM_ABI void reset();
};

// operator()的实现
template <class _Rp, class... _ArgTypes>
void packaged_task<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __args) {
    if (__p_.__state_ == nullptr)
        std::__throw_future_error(future_errc::no_state);
    if (__p_.__state_->__has_value())
        std::__throw_future_error(future_errc::promise_already_satisfied);
        
#if _LIBCPP_HAS_EXCEPTIONS
    try {
#endif
        // 执行包装的函数并设置结果
        __p_.set_value(__f_(std::forward<_ArgTypes>(__args)...));
#if _LIBCPP_HAS_EXCEPTIONS
    } catch (...) {
        // 捕获异常并设置到promise中
        __p_.set_exception(current_exception());
    }
#endif
}
```

### 4.7 packaged_task与future的关联机制

`packaged_task`通过内部的`promise`对象与`future`建立关联：

```cpp
// packaged_task获取future的过程
template <class _Rp, class... _ArgTypes>
future<_Rp> packaged_task<_Rp(_ArgTypes...)>::get_future() {
    // 直接委托给内部promise的get_future方法
    return __p_.get_future();
}

// 执行时设置结果的过程
template <class _Rp, class... _ArgTypes>
void packaged_task<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __args) {
    // 检查状态有效性
    if (__p_.__state_ == nullptr)
        std::__throw_future_error(future_errc::no_state);
    if (__p_.__state_->__has_value())
        std::__throw_future_error(future_errc::promise_already_satisfied);
        
    try {
        // 执行包装的函数，并通过promise设置结果
        // 这会通知所有等待的future对象
        __p_.set_value(__f_(std::forward<_ArgTypes>(__args)...));
    } catch (...) {
        // 异常也通过promise传递给future
        __p_.set_exception(current_exception());
    }
}
```

### 4.8 std::async实现

`std::async`提供便捷的异步执行接口，根据启动策略创建不同类型的共享状态。

```cpp
// 异步函数包装器
template <class _Fp, class... _Args>
class _LIBCPP_HIDDEN __async_func {
    tuple<_Fp, _Args...> __f_; // 存储函数和参数

public:
    using _Rp = __invoke_result_t<_Fp, _Args...>; // 推导返回类型

    // 构造函数：完美转发函数和参数
    _LIBCPP_HIDE_FROM_ABI explicit __async_func(_Fp&& __f, _Args&&... __args)
        : __f_(std::move(__f), std::move(__args)...) {}

    // 移动构造函数
    _LIBCPP_HIDE_FROM_ABI __async_func(__async_func&& __f) 
        : __f_(std::move(__f.__f_)) {}

    // 调用操作符：展开tuple并调用函数
    _LIBCPP_HIDE_FROM_ABI _Rp operator()() {
        typedef typename __make_tuple_indices<1 + sizeof...(_Args), 1>::type _Index;
        return __execute(_Index());
    }

private:
    // 使用索引序列展开tuple并调用
    template <size_t... _Indices>
    _LIBCPP_HIDE_FROM_ABI _Rp __execute(__tuple_indices<_Indices...>) {
        return std::__invoke(std::move(std::get<0>(__f_)), 
                           std::move(std::get<_Indices>(__f_))...);
    }
};

// 检查启动策略是否包含指定值
inline _LIBCPP_HIDE_FROM_ABI bool __does_policy_contain(launch __policy, launch __value) {
    return (int(__policy) & int(__value)) != 0;
}

// 创建延迟执行的共享状态
template <class _Rp, class _Fp>
_LIBCPP_HIDE_FROM_ABI future<_Rp> __make_deferred_assoc_state(_Fp&& __f) {
    // 创建延迟执行状态，使用RAII管理内存
    unique_ptr<__deferred_assoc_state<_Rp, _Fp>, __release_shared_count> __h(
        new __deferred_assoc_state<_Rp, _Fp>(std::forward<_Fp>(__f)));
    return future<_Rp>(__h.get()); // 返回关联的future
}

// 创建异步执行的共享状态
template <class _Rp, class _Fp>
_LIBCPP_HIDE_FROM_ABI future<_Rp> __make_async_assoc_state(_Fp&& __f) {
    // 创建异步执行状态
    unique_ptr<__async_assoc_state<_Rp, _Fp>, __release_shared_count> __h(
        new __async_assoc_state<_Rp, _Fp>(std::forward<_Fp>(__f)));
    // 立即启动线程执行任务
    std::thread(&__async_assoc_state<_Rp, _Fp>::__execute, __h.get()).detach();
    return future<_Rp>(__h.get()); // 返回关联的future
}

// std::async的主要实现
template <class _Fp, class... _Args>
[[__nodiscard__]] _LIBCPP_HIDE_FROM_ABI 
future<__invoke_result_t<__decay_t<_Fp>, __decay_t<_Args>...>>
async(launch __policy, _Fp&& __f, _Args&&... __args) {
    typedef __async_func<__decay_t<_Fp>, __decay_t<_Args>...> _BF;
    typedef typename _BF::_Rp _Rp;

#if _LIBCPP_HAS_EXCEPTIONS
    try {
#endif
        // 如果策略包含async，尝试异步执行
        if (__does_policy_contain(__policy, launch::async))
            return std::__make_async_assoc_state<_Rp>(
                _BF(std::forward<_Fp>(__f), std::forward<_Args>(__args)...));
#if _LIBCPP_HAS_EXCEPTIONS
    } catch (...) {
        // 如果只允许async但失败了，重新抛出异常
        if (__policy == launch::async)
            throw;
    }
#endif

    // 如果策略包含deferred，创建延迟执行
    if (__does_policy_contain(__policy, launch::deferred))
        return std::__make_deferred_assoc_state<_Rp>(
            _BF(std::forward<_Fp>(__f), std::forward<_Args>(__args)...));
            
    // 如果都不支持，返回无效的future
    return future<_Rp>{};
}

// 默认策略的async重载
template <class _Fp, class... _Args>
[[__nodiscard__]] inline _LIBCPP_HIDE_FROM_ABI 
future<__invoke_result_t<__decay_t<_Fp>, __decay_t<_Args>...>>
async(_Fp&& __f, _Args&&... __args) {
    // 默认使用launch::any策略（async | deferred）
    return std::async(launch::any, std::forward<_Fp>(__f), 
                     std::forward<_Args>(__args)...);
}
```

