## 一、对称协程和非对称协程的概念
### ​**​1. 对称协程**​

- ​**​定义​**​：所有协程是平等的，任何协程可以直接将控制权转移给其他协程，无需通过中心调度点。
- ​**​特点​**​：
    - ​**​对等性​**​：协程之间是平等的，没有明确的调用者/被调用者关系。
    - ​**​自由切换​**​：协程A可以主动跳转到协程B，协程B也可以直接跳转到协程A或其他协程。
    - ​**​无主从关系​**​：没有“主协程”概念，调度逻辑由协程自行决定。
- ​**​示例​**​：
    
    ```
    -- Lua的对称协程（通过`coroutine.transfer`直接切换）
    co1 = coroutine.create(function() coroutine.transfer(co2) end)
    co2 = coroutine.create(function() coroutine.transfer(co1) end)
    coroutine.resume(co1) -- 在co1和co2之间自由切换
    ```
    
- ​**​典型应用​**​：协作式任务调度、状态机实现。

### ​**​2. 非对称协程​**​

- ​**​定义​**​：协程之间存在调用层级关系，控制权必须通过特定的调用点（如`yield`和`resume`）转移。
- ​**​特点​**​：
    - ​**​主从关系​**​：存在一个“调用者”（如主线程或调度器），协程只能将控制权返回给调用者。
    - ​**​受限切换​**​：协程通过`yield`挂起自身并将控制权交还给调用者，调用者通过`resume`恢复协程。
- ​**​示例​**​：
    
    ```
    # Python的非对称协程（通过yield和send控制）
    def coroutine():
        while True:
            value = yield  # 挂起并返回控制权给调用者
            print("Received:", value)
    
    co = coroutine()
    next(co)  # 启动协程
    co.send(42)  # 调用者恢复协程并传值
    ```
    
- ​**​典型应用​**​：生成器（Generators）、I/O多路复用（如Python的asyncio）。
### ​**​核心区别​**​

| ​**​特性​**​    | ​**​对称协程​**​ | ​**​非对称协程​**​      |
| ------------- | ------------ | ------------------ |
| ​**​控制权转移​**​ | 协程间直接自由切换    | 必须通过调用者（如`resume`） |




## 二、C++20协程机制的对称性问题
个人认为C++20的协程机制不属于对称也不属于非对称，这取决于你的代码实现，C++20协程机制只是给你了机制，除了无栈协程是定死的，其他东西全都可以自由发挥。利用C++20协程机制，既可以实现对称协程，也可以实现非对称协程。

#### C++协程机制对称性不定的根本原因-awaitable的`await_suspend()`接口
#### `await_suspend()`
**1. `void`返回值**：
- **含义**：协程被挂起，需要外部代码手动恢复
- **行为**：协程保持挂起状态，直到某处调用`handle.resume()`

**2. `bool`返回值**：
- **含义**：根据返回值决定协程是否保持挂起
- **行为**：
  - 返回`true`：协程保持挂起状态
  - 返回`false`：立即恢复协程执行

**3. `std::coroutine_handle<>`返回值**：
- **含义**：挂起当前协程，立即恢复指定的协程
- **行为**：编译器自动调用返回句柄的`resume()`方法


### 非对称协程代码示例-链式调用：
```cpp
#include<thread>  
#include <coroutine>  
#include <exception>  
#include <iostream>  
#include <optional>  
#include <print>  
#include <utility>  
class task {  
public:  
    // 实现promsie对象  
    struct promise {  
        std::exception_ptr exception;  
        std::coroutine_handle<> father_handler;  
  
        auto get_return_object() {  
            return task{std::coroutine_handle<promise>::from_promise(*this)};  
        }  
        std::suspend_never initial_suspend() { return {}; }  
        auto final_suspend() noexcept {  
            // 定义一个最终返回的awiatable对象  
            struct FinalAwaiter {  
                // 挂起  
                bool await_ready() noexcept { return false; }  
                // 如果该协程有父句柄，返回他的句柄，否则返回一个空的协程  
                std::coroutine_handle<> await_suspend(  
                        std::coroutine_handle<promise> h) noexcept {  
                    if (h.promise().father_handler) {  
                        return h.promise().father_handler;  
                    }  
                    return std::noop_coroutine();  
                }  
                void await_resume() noexcept {}  
            };  
            return FinalAwaiter{};  
        }  
        void unhandled_exception() { exception = std::current_exception(); }  
  
        void return_void() {}  
    };  
  
public:  
    using promise_type = promise;  
    using handle_type = std::coroutine_handle<promise>;  
  
public:  
    bool await_ready() const { return handle_.done(); }  
    void await_suspend(std::coroutine_handle<> caller) noexcept {  
        handle_.promise().father_handler = caller;  
        if (!handle_.done() && handle_) {  
            handle_.resume();  
        }  
    }  
  
    void await_resume() noexcept {}  
  
public:  
    task(const task&) = delete;  
    task& operator=(const task&) = delete;  
    explicit task(handle_type h) : handle_(h) {}  
    ~task() {  
        if (handle_) {  
            handle_.destroy();  
        }  
    }  
  
    task(task&& other) noexcept : handle_(std::exchange(other.handle_, {})) {}  
  
public:  
  
    auto get_address() { return handle_.address(); }  
  
private:  
    handle_type handle_;  
};  
  
task coro1() {  
    std::cout << "Starting coroutine1" << std::endl;  
    co_await std::suspend_always{};  
    std::this_thread::sleep_for(std::chrono::seconds(1));  
    std::cout << "finish coroutine1" << std::endl;  
    co_return;  
}  
task coro2() {  
    std::cout << "Starting coroutine2" << std::endl;  
    co_await coro1();  
    std::cout << "finish coroutine2" << std::endl;  
    co_return;  
}  
task coro3() {  
    std::cout << "Starting coroutine3" << std::endl;  
    co_await coro2();  
    std::cout << "finish coroutine3" << std::endl;  
    co_return;  
}  
  
task coro(){  
    co_await coro3();  
    co_return;  
}  
  
  
int main() {  
    auto h = coro();  
    return 0;  
}
```


### 对称协程示例代码：
```cpp
  
#include <coroutine>  
#include <iostream>  
#include <memory>  
#include <string>  
#include <unordered_map>  
  
// 前向声明  
class CoroutineManager;  
  
// 协程句柄包装器  
struct Coroutine {  
    using coro_context = std::shared_ptr<Coroutine>;  
    std::coroutine_handle<> handle;  
    std::string name;  
    bool finished = false;  
  
    Coroutine(std::coroutine_handle<> h, const std::string& n)  
            : handle(h), name(n) {}  
  
    ~Coroutine() {  
        if (handle && !handle.done()) {  
            handle.destroy();  
        }  
    }  
  
    // 禁止拷贝，允许移动  
    Coroutine(const Coroutine&) = delete;  
    Coroutine& operator=(const Coroutine&) = delete;  
    Coroutine(Coroutine&& other) noexcept  
            : handle(other.handle),  
              name(std::move(other.name)),  
              finished(other.finished) {  
        other.handle = nullptr;  
    }  
    Coroutine& operator=(Coroutine&& other) noexcept {  
        if (this != &other) {  
            if (handle && !handle.done()) {  
                handle.destroy();  
            }  
            handle = other.handle;  
            name = std::move(other.name);  
            finished = other.finished;  
            other.handle = nullptr;  
        }  
        return *this;  
    }  
};  
  
// 协程管理器  
class CoroutineManager {  
public:  
    static CoroutineManager& instance() {  
        static CoroutineManager mgr;  
        return mgr;  
    }  
  
    std::shared_ptr<Coroutine> current_coroutine;  
    std::unordered_map<std::string, std::shared_ptr<Coroutine>> coroutines;  
  
    void register_coroutine(const std::string& name,  
                            std::shared_ptr<Coroutine> coro) {  
        coroutines[name] = coro;  
    }  
  
    std::shared_ptr<Coroutine> get_coroutine(const std::string& name) {  
        auto it = coroutines.find(name);  
        return (it != coroutines.end()) ? it->second : nullptr;  
    }  
};  
  
// 协程返回类型  
struct CoroTask {  
    struct promise_type {  
        CoroTask get_return_object() {  
            return CoroTask{std::coroutine_handle<promise_type>::from_promise(*this)};  
        }  
  
        std::suspend_never initial_suspend() { return {}; }  
  
  
  
  
        std::suspend_always final_suspend() noexcept { return {}; }  
  
        void return_void() {}  
        void unhandled_exception() {}  
    };  
  
    std::coroutine_handle<promise_type> handle;  
  
    CoroTask(std::coroutine_handle<promise_type> h) : handle(h) {}  
  
    ~CoroTask() {  
        if (handle) {  
            handle.destroy();  
        }  
    }  
  
    // 禁止拷贝，允许移动  
    CoroTask(const CoroTask&) = delete;  
    CoroTask& operator=(const CoroTask&) = delete;  
    CoroTask(CoroTask&& other) noexcept : handle(other.handle) {  
        other.handle = nullptr;  
    }  
    CoroTask& operator=(CoroTask&& other) noexcept {  
        if (this != &other) {  
            if (handle) handle.destroy();  
            handle = other.handle;  
            other.handle = nullptr;  
        }  
        return *this;  
    }  
};  
  
namespace coro {  
  
// 创建协程  
    template <typename Func>  
    std::shared_ptr<Coroutine> create(Func&& func) {  
        auto task = func();  
        static int counter = 0;  
        std::string auto_name = "auto_coro_" + std::to_string(++counter);  
        auto coro = std::make_shared<Coroutine>(task.handle, auto_name);  
        // 将 task 的所有权转移，避免过早销毁  
        task.handle = nullptr;  // 防止 task 析构时销毁句柄  
        CoroutineManager::instance().register_coroutine(auto_name, coro);  
        return coro;  
    }  
  
// 恢复协程  
    bool resume(std::shared_ptr<Coroutine> coro) {  
        if (!coro || coro->finished || coro->handle.done()) {  
            return false;  
        }  
  
        CoroutineManager::instance().current_coroutine = coro;  
        coro->handle.resume();  
  
        if (coro->handle.done()) {  
            coro->finished = true;  
        }  
  
        return true;  
    }  
  
// yield到指定协程  
    struct YieldToCoroAwaiter {  
        std::shared_ptr<Coroutine> target_coro;  
  
        YieldToCoroAwaiter(std::shared_ptr<Coroutine> coro) : target_coro(coro) {}  
  
        bool await_ready() { return false; }  
  
        std::coroutine_handle<> await_suspend(std::coroutine_handle<> handle) {  
            // 返回目标协程句柄而不是直接恢复，避免递归调用  
            if (target_coro && !target_coro->finished && !target_coro->handle.done()) {  
                CoroutineManager::instance().current_coroutine = target_coro;  
                return target_coro->handle;  
            }  
            return std::noop_coroutine();  
        }  
  
        void await_resume() {}  
    };  
  
// 简单yield（挂起当前协程）  
    struct SimpleYieldAwaiter {  
        bool await_ready() { return false; }  
        void await_suspend(std::coroutine_handle<> handle) {}  
        void await_resume() {}  
    };  
  
    YieldToCoroAwaiter yield(std::shared_ptr<Coroutine> target_coro) {  
        return YieldToCoroAwaiter(target_coro);  
    }  
  
    SimpleYieldAwaiter yield() { return SimpleYieldAwaiter{}; }  
  
    std::string status(std::shared_ptr<Coroutine> coro) {  
        if (!coro) return "not found";  
        if (coro->finished || coro->handle.done()) return "dead";  
        return "suspended";  
    }  
}  // namespace coro  
  
  
  
  
// 示例  
Coroutine::coro_context coro_a, coro_b;  
CoroTask coroutine_a() {  
    for (int i = 0; i < 4; ++i) {  
        std::cout << "协程A执行第" << i+1 << "步" << std::endl;  
            std::cout << "协程A切换到协程B" << std::endl;  
            co_await coro::yield(coro_b);  
    }  
    std::cout << "协程A完成" << std::endl;  
}  
  
CoroTask coroutine_b() {  
    int i=0;  
    while(true) {  
        if(coro_a->finished == true) break;  
        std::cout << "协程B执行第" << i+1 << "步" << std::endl;  
            std::cout << "协程B切换到协程A" << std::endl;  
            co_await coro::yield(coro_a);  
            i++;  
    }  
    std::cout << "协程B完成" << std::endl;  
}  
void test_symmetric_coroutines() {  
    // 创建三个协程  
    coro_a = coro::create(coroutine_a);  
    coro_b = coro::create(coroutine_b);  
    std::cout << "开始执行协程A" << std::endl;  
  
    // 启动协程A，它会自动切换到其他协程  
    coro::resume(coro_a);  
    coro::resume(coro_b);  
  
    std::cout << "\n所有协程执行完毕" << std::endl;  
    std::cout << "协程A状态: " << coro::status(coro_a) << std::endl;  
    std::cout << "协程B状态: " << coro::status(coro_b) << std::endl;  
  
}  
  
int main() {  
    test_symmetric_coroutines();  
    return 0;  
}
```