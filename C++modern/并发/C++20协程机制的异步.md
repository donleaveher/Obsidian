
## 从一个简单的传统异步程序开始

让我们从一个最简单的异步操作开始探索：

```cpp
#include <chrono>
#include <future>
#include <iostream>
#include <mutex>
#include <thread>

int main() {
  std::mutex mtx;
  //提交一个异步任务
  auto f = std::async([&]() {
    {
      std::lock_guard<std::mutex> lock(mtx);
      std::cout << "子线程开始.....\n";
    }
    int sum = 0;
    return sum;
  });
  // 调用get方法获取到线程的结果
  auto res = f.get();
  std::cout << "主线程get value: " << res << std::endl;
  return 0;
}
```

## 异步操作的本质抽象

通过观察以上代码，我们或许可以将异步操作抽象为两个核心动作：

```
异步操作 = 提交(Submit) + 获取/等待(Retrieve)
```

这种抽象的普适性可以在各种异步模式中得到验证：

### 回调模式
```cpp
// 提交：注册回调
http_get("https://api.example.com", [](Response response) {
    // 等待/获取：等待回调被调用，如果有结果可以获取结果
    process(response);
});
```


## Awaitable-异步操作的好帮手

### Awaitable与"提交-获取"的契合
C++20协程通过Awaitable概念完美实现了"提交-获取"抽象：
> **Awaitable可以让异步的操作能够以同步操作的方式被使用。**

```cpp
struct MyAwaitable {
    bool await_ready() { 
        // 检查是否已经完成（优化：避免不必要的挂起）
        return false; 
    }
    
    void await_suspend(std::coroutine_handle<> handle) {
        // 提交阶段：启动异步操作，保存协程句柄
        start_async_operation([handle](auto result) {
            // 异步操作完成时恢复协程
            handle.resume();
        });
    }
    
    int await_resume() {
        // 获取阶段：返回异步操作的结果
        return get_result();
    }
};
```

### co_await表达式的异步语义

```cpp
Task<int> async_function() {
    int result = co_await MyAwaitable{};
    co_return result;
}
```

- 协程挂起，提交异步操作
- 调度器调度其他协程，恢复其他协程
- 等待调度器再次调度到此协程，恢复协程获取结果


**示例代码（配合异步操作读取文件的awaitable对象）**
```cpp
#include <coroutine>  
#include <exception>  
#include <fstream>  
#include <future>  
#include <iostream>  
#include <optional>  
class Task {  
public:  
    struct promise_type {  
        Task get_return_object() {  
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};  
        }  
        std::suspend_never initial_suspend() {  
            return {};  
        }  
        std::suspend_always final_suspend() noexcept {  
            return {};  
        }  
        void return_void() {}  
        void unhandled_exception() {  
            std::terminate();  
        }  
    };  
  
public:  
    Task(std::coroutine_handle<promise_type> h) : handle(h) {}  
  
    ~Task() {  
        if (handle) {  
            handle.destroy();  
        }  
    }  
  
    bool resume() {  
        if (handle && !handle.done()) {  
            handle.resume();  
            return true;  
        }  
        return false;  
    }  
  
private:  
    std::coroutine_handle<promise_type> handle;  
};  
  
class read {  
public:  
    explicit read(std::string str) : file_path(str) {}  
  
    bool await_ready() {  
        return false;  
    }  
  
    void await_suspend(std::coroutine_handle<> h) {  
        //提交了一个读取文件内容的异步操作  
        f = std::async([&]() -> std::optional<std::string> {  
            std::ifstream file(file_path);  
            if (file.is_open()) {  
                std::stringstream buffer;  
                buffer << file.rdbuf();  
                file.close();  
                return buffer.str();  
            } else {  
                std::cerr << "无法打开文件" << std::endl;  
                return std::nullopt;  
            }  
        });  
    }  
  
    std::optional<std::string> await_resume() {  
        //返回异步结果  
        return f.get();  
    }  
  
private:  
    std::string              file_path;  
    std::future<std::optional<std::string>> f;  
};  
  
// 协程  
Task simple_coroutine() {  
    auto res = co_await read("test.txt");  
    if(!res.has_value()) {  
        co_return;  
    }  
    std::cout << "协程获取数据：" << res.value() << std::endl;  
    co_return;  
}  
  
int main() {  
    Task h = simple_coroutine();  
    h.resume();  
    return 0;  
}
```


## C++20协程机制的异步

- C++20协程的同步异步取决于调度器
- C++20协程既可以是同步的也可以是异步的
- C++20协程完全可以是异步的

C++20协程机制本身没有提供协程调度，只要的调度器不是一定要等一个协程执行完再去执行另一个协程，他一定是异步执行的。
### 异步的本质
**异步**：程序可以启动一个任务，然后不等待它完成就继续执行其他任务，当任务完成时会通过某种方式通知程序

**同步示例代码（带一个简单调度器的异步读取文件）**
```cpp
#include <coroutine>  
#include <fstream>  
#include <future>  
#include <exception>  
#include <iostream>  
#include <optional>  
#include <utility>  
template<typename T = void>  
class Task {  
public:  
    struct promise_type {  
        Task get_return_object() {  
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};  
        }  
  
        std::suspend_always initial_suspend() { return {}; }  
        std::suspend_always final_suspend() noexcept { return {}; }  
  
        void return_void() {}  
        void unhandled_exception() {}  
    };  
  
    Task(std::coroutine_handle<promise_type> handle) : handle_(handle) {}  
  
    Task(Task&& other) noexcept : handle_(std::exchange(other.handle_, {})) {}  
  
    ~Task() {  
        if (handle_) {  
            handle_.destroy();  
        }  
    }  
  
    Task(const Task&) = delete;  
    Task& operator=(const Task&) = delete;  
  
    std::coroutine_handle<promise_type> get_handle() const { return handle_; }  
    bool done() const { return handle_.done(); }  
  
private:  
    std::coroutine_handle<promise_type> handle_;  
};  
  
// 简单的调度器  
class SimpleScheduler {  
public:  
    static SimpleScheduler& instance() {  
        static SimpleScheduler scheduler;  
        return scheduler;  
    }  
  
    void schedule(std::coroutine_handle<> handle) {  
        ready_queue_.push(handle);  
    }  
  
    void run() {  
        while (!ready_queue_.empty()) {  
            auto handle = ready_queue_.front();  
            ready_queue_.pop();  
  
            //循环恢复同一个协程，直到他运行完毕  
            while (handle && !handle.done()) {  
                handle.resume();  
            }  
        }  
    }  
  
private:  
    std::queue<std::coroutine_handle<>> ready_queue_;  
};  
  
  
class read {  
public:  
    explicit read(std::string str) : file_path(str) {}  
  
    bool await_ready() {  
        return false;  
    }  
  
    void await_suspend(std::coroutine_handle<> h) {  
        //提交了一个读取文件内容的异步操作  
        f = std::async([&]() -> std::optional<std::string> {  
            std::ifstream file(file_path);  
            if (file.is_open()) {  
                std::stringstream buffer;  
                buffer << file.rdbuf();  
                file.close();  
                return buffer.str();  
            } else {  
                std::cerr << "无法打开文件" << std::endl;  
                return std::nullopt;  
            }  
        });  
        std::cout << "读取协程提交了读取操作...\n";  
    }  
  
    std::optional<std::string> await_resume() {  
        //返回异步结果  
        return f.get();  
    }  
  
private:  
    std::string              file_path;  
    std::future<std::optional<std::string>> f;  
};  
  
  
Task<> coro() {  
    std::cout << "读取协程开始...\n";  
    std::cout << "读取协程开始读取...\n";  
    auto res = co_await read("test.txt");  
    if(!res.has_value()) {  
        co_return;  
    }  
    std::cout << "协程获取数据：" << res.value() << std::endl;  
    co_return;  
}  
  
  
Task<> simple_coroutine1() {  
    std::cout << "协程1开始...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程1恢复...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程1恢复...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程1结束...\n";  
    co_return;  
}  
  
Task<> simple_coroutine2() {  
    std::cout << "协程2开始...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程2恢复...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程2结束...\n";  
    co_return;  
}  
  
int main() {  
    auto& scheduler = SimpleScheduler::instance();  
    // 创建并调度协程任务  
    std::vector<Task<>> tasks;  
    tasks.push_back(coro());  
    tasks.push_back(simple_coroutine1());  
    tasks.push_back(simple_coroutine2());  
    // 调度所有任务  
    for (auto& task : tasks) {  
        scheduler.schedule(task.get_handle());  
    }  
  
    // 运行调度器  
    scheduler.run();  
    return 0;  
}
```


**异步示例代码（带一个简单调度器的异步读取文件）**

```cpp
#include <coroutine>  
#include <fstream>  
#include <future>  
#include <exception>  
#include <iostream>  
#include <optional>  
#include <utility>  
template<typename T = void>  
class Task {  
public:  
    struct promise_type {  
        Task get_return_object() {  
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};  
        }  
  
        std::suspend_always initial_suspend() { return {}; }  
        std::suspend_always final_suspend() noexcept { return {}; }  
  
        void return_void() {}  
        void unhandled_exception() {}  
    };  
  
    Task(std::coroutine_handle<promise_type> handle) : handle_(handle) {}  
  
    Task(Task&& other) noexcept : handle_(std::exchange(other.handle_, {})) {}  
  
    ~Task() {  
        if (handle_) {  
            handle_.destroy();  
        }  
    }  
  
    Task(const Task&) = delete;  
    Task& operator=(const Task&) = delete;  
  
    std::coroutine_handle<promise_type> get_handle() const { return handle_; }  
    bool done() const { return handle_.done(); }  
  
private:  
    std::coroutine_handle<promise_type> handle_;  
};  
  
// 简单的调度器  
class SimpleScheduler {  
public:  
    static SimpleScheduler& instance() {  
        static SimpleScheduler scheduler;  
        return scheduler;  
    }  
  
    void schedule(std::coroutine_handle<> handle) {  
        ready_queue_.push(handle);  
    }  
  
    void run() {  
        while (!ready_queue_.empty()) {  
            auto handle = ready_queue_.front();  
            ready_queue_.pop();  
  
            if (handle && !handle.done()) {  
                handle.resume();  
                if(!handle.done())  
                    //std::cout<<"当前协程还没执行完毕，继续放入队列等待调度\n";  
                    ready_queue_.push(handle);  
            }  
        }  
    }  
  
private:  
    std::queue<std::coroutine_handle<>> ready_queue_;  
};  
  
  
class read {  
public:  
    explicit read(std::string str) : file_path(str) {}  
  
    bool await_ready() {  
        return false;  
    }  
  
    void await_suspend(std::coroutine_handle<> h) {  
        //提交了一个读取文件内容的异步操作  
        f = std::async([&]() -> std::optional<std::string> {  
            std::ifstream file(file_path);  
            if (file.is_open()) {  
                std::stringstream buffer;  
                buffer << file.rdbuf();  
                file.close();  
                return buffer.str();  
            } else {  
                std::cerr << "无法打开文件" << std::endl;  
                return std::nullopt;  
            }  
        });  
        std::cout << "读取协程提交了读取操作...\n";  
    }  
  
    std::optional<std::string> await_resume() {  
        //返回异步结果  
        return f.get();  
    }  
  
private:  
    std::string              file_path;  
    std::future<std::optional<std::string>> f;  
};  
  
  
Task<> coro() {  
    std::cout << "读取协程开始...\n";  
    std::cout << "读取协程开始读取...\n";  
    auto res = co_await read("test.txt");  
    if(!res.has_value()) {  
        co_return;  
    }  
    std::cout << "协程获取数据：" << res.value() << std::endl;  
    co_return;  
}  
  
  
Task<> simple_coroutine1() {  
    std::cout << "协程1开始...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程1恢复...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程1恢复...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程1结束...\n";  
    co_return;  
}  
  
Task<> simple_coroutine2() {  
    std::cout << "协程2开始...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程2恢复...\n";  
    co_await std::suspend_always{};  
    std::cout << "协程2结束...\n";  
    co_return;  
}  
  
int main() {  
    auto& scheduler = SimpleScheduler::instance();  
    // 创建并调度协程任务  
    std::vector<Task<>> tasks;  
    tasks.push_back(coro());  
    tasks.push_back(simple_coroutine1());  
    tasks.push_back(simple_coroutine2());  
    // 调度所有任务  
    for (auto& task : tasks) {  
        scheduler.schedule(task.get_handle());  
    }  
  
    // 运行调度器  
    scheduler.run();  
    return 0;  
}
```