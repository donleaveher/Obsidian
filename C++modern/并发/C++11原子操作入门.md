
## 什么是原子操作
原子操作（Atomic Operation）是指在多线程环境中，一个操作要么完全执行，要么完全不执行，不会被其他线程中断的操作。原子操作是线程安全的，可以避免数据竞争（Data Race）问题。

## 一.C++11原子类

### 1. std::atomic模板类

```cpp
#include <atomic>

std::atomic<int> counter{0};
std::atomic<bool> flag{false};
std::atomic<double> value{3.14};
```

### 2.std::atomic模板类别名
```cpp
using std::atomic_bool   = std::atomic<bool>;
using std::atomic_char   = std::atomic<char>;
using std::atomic_short  = std::atomic<short>;
using std::atomic_int    = std::atomic<int>;
using std::atomic_long   = std::atomic<long>;
using std::atomic_int8_t   = std::atomic< int8_t>;
using std::atomic_uint8_t  = std::atomic<uint8_t>;
using std::atomic_int16_t  = std::atomic< int16_t>;
using std::atomic_uint16_t = std::atomic<uint16_t>;
using std::atomic_int32_t  = std::atomic< int32_t>;
using std::atomic_uint32_t = std::atomic<uint32_t>;
using std::atomic_int64_t  = std::atomic< int64_t>;
using std::atomic_uint64_t = std::atomic<uint64_t>;
using std::atomic_size_t    = std::atomic<size_t>;

```



## 二.C++原子基本操作

### 读取和写入
```cpp
std::atomic<int> x{10};
// 原子读取
int val = x.load();
// 原子写入
x.store(20);
// 或者当成普通变量一样使用
std::atomic_int y = 10;
int m = 30;
y = 20;
y >= 20;   //比较
y = m;

//注意两个原子变量之间不能直接赋值。
y = x   //编译错误

```

### 交换操作
```cpp
std::atomic<int> x{10};

// 原子交换，返回旧值
int old_val = x.exchange(20);

// 比较并交换（CAS操作）
int expected = 20;
bool success = x.compare_exchange_weak(expected, 30);
// 如果x等于expected，则将x设为30，返回true
// 否则将expected设为x的当前值，返回false
```

### 算术操作（仅适用于整数类型）
```cpp
std::atomic<int> counter{0};

// 原子递增/递减
counter++;
++counter;
counter--;
--counter;

// 原子加法/减法
counter += 5;
counter -= 3;

// 获取旧值的操作
int old_val = counter.fetch_add(10);  // 返回加法前的值
int old_val2 = counter.fetch_sub(5);  // 返回减法前的值
```

### 位操作（仅适用于整数类型）
```cpp
std::atomic<int> flags{0};

flags |= 0x01;  // 原子或操作
flags &= 0xFE;  // 原子与操作
flags ^= 0x01;  // 原子异或操作

// 获取旧值的位操作
int old_val = flags.fetch_or(0x02);
int old_val2 = flags.fetch_and(0xFD);
int old_val3 = flags.fetch_xor(0x04);
```



  
## 三 C++的五种内存序 

**CPU执行指令真的会严格按照我们写代码的顺序执行吗**
**答案是：不一定！**
假设我们有这样的代码：
```cpp
int a = 0;
int b = 0; 


void function() {
    a = 1;  // 语句1
    b = 2;  // 语句2 
}
```

**你觉得CPU会按照 1→2→的顺序执行吗？**
CPU实际可能按以下任意顺序执行：
- `a = 1; b = 2;` 
- `b = 2; a = 1;`

### 内存序：解决乱序执行的工具
**内存序（memory ordering）就是用来控制这种内存操作指令执行顺序的机制。**
#### 核心作用
内存序解决两个关键问题：
1. **防止指令重排序** - 在关键点设置"屏障"，确保重要操作按预期顺序执行
2. **控制内存可见性** - 确保一个线程的修改能被其他线程在正确的时机看到
**记住：** CPU的乱序执行是为了性能，但在多线程环境下需要我们用内存序来精确控制。


### C++的五种内存序

```cpp
typedef enum memory_order {  
    memory_order_relaxed,  
    memory_order_consume,(已弃用)  
    memory_order_acquire,  
    memory_order_release,  
    memory_order_acq_rel,  
    memory_order_seq_cst  
} memory_order;
```

### 1. memory_order_seq_cst（顺序一致性，默认）

 这是最严格的内存序，提供全局的顺序一致性。所有使用此内存序的操作在所有线程中都有一个全局的、一致的执行顺序。
### 2. memory_order_relaxed（松散序）

 最宽松的内存序，只保证操作的原子性，不提供任何同步或排序约束。不同线程可能以不同的顺序看到relaxed操作。

### 3. memory_order_release（发布语义）

 用于写操作，建立"发布"语义。确保在此release操作之前的所有内存操作都不能被重排序到此操作之后。（数据生产者）

### 4. memory_order_acquire（获取语义）

 用于读操作，建立"获取"语义。确保在此acquire操作之后的所有内存操作（读写）都不能被重排序到此操作之前。（数据消费者）
### 5. memory_order_acq_rel（获取-发布语义）

 结合了acquire和release语义。对于读-修改-写操作，既不允许前面的操作重排序到后面，也不允许后面的操作重排序到前面。



## 四. 哪些类型可以作为原子类型-平凡可拷贝类型

**核心**：`std::atomic<T>` 要求 `T` 是平凡可拷贝的。
#### 1. 平凡可拷贝定义
可以通过 `memcpy` 安全复制的类型。
#### 2. 平凡可拷贝条件
- 默认的拷贝构造函数
- 默认的拷贝赋值运算符
- 默认的析构函数
- 无用户定义的移动操作
- 无虚函数和虚基类
- 所有成员都是平凡可拷贝的

#### 3. 不能作为原子类型的条件
- 自定义拷贝/赋值/析构函数
- 自定义移动操作
- 有虚函数或虚基类
- 包含非平凡可拷贝成员
- 引用类型、函数类型、数组类型
- 标准库复杂类型 (stl容器,unique_ptr)（`std::string`、`std::vector` 等）



## 实际应用示例

```cpp
#include <atomic>
#include <thread>
#include <vector>
#include <iostream>

class ThreadSafeCounter {
private:
    std::atomic<int> count{0};
    
public:
    void increment() {
        count.fetch_add(1);
    }
    
    int get() const {
        return count.load();
    }
};

int main() {
    ThreadSafeCounter counter;
    std::vector<std::thread> threads;
    
    // 启动10个线程，每个线程递增1000次
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back([&counter]() {
            for (int j = 0; j < 1000; ++j) {
                counter.increment();
            }
        });
    }
    
    // 等待所有线程完成
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Final count: " << counter.get() << std::endl;
    // 输出应该是10000
    
    return 0;
}
```

