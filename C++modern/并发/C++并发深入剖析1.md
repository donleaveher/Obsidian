

本文档将深入分析LLVM libc++项目中C++标准库并发组件的真实源码实现，包括`std::thread`、`std::mutex`、`std::lock_guard`、`std::unique_lock`和`std::condition_variable`，以及底层的POSIX平台抽象层。


## 1. std::thread 源码实现分析

### 1.1 实现概述

`std::thread`封装了操作系统线程，提供了C++风格的线程创建和管理接口。

### 1.2 源码实现

```cpp
class _LIBCPP_EXPORTED_FROM_ABI thread
{
public:
    typedef __libcpp_thread_t native_handle_type;  // 平台相关的线程句柄类型
    
    class _LIBCPP_EXPORTED_FROM_ABI id;
    
private:
    __libcpp_thread_t __t_;  // 底层线程句柄
    
    // 线程启动的内部实现
    template <class _Fp, class ..._Args>
    static void* __thread_proxy(void* __vp) {
        // 从参数中恢复函数对象和参数
        __thread_invoke_pair<_Fp, _Args...>* __p = 
            static_cast<__thread_invoke_pair<_Fp, _Args...>*>(__vp);
        
        // 创建局部副本并删除堆分配的对象
        __thread_invoke_pair<_Fp, _Args...> __invoke_pair = *__p;
        delete __p;
        
        // 调用用户函数
        __invoke_pair();
        return nullptr;
    }
    
public:
    // 默认构造函数
    _LIBCPP_INLINE_VISIBILITY
    thread() noexcept : __t_(_LIBCPP_NULL_THREAD) {}
    
    // 函数对象构造函数
    template <class _Fp, class ..._Args,
              class = typename enable_if
              <
                   !is_same<typename __uncvref<_Fp>::type, thread>::value
              >::type
             >
    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
    explicit thread(_Fp&& __f, _Args&&... __args) {
        // 创建线程参数包装器
        typedef __thread_invoke_pair<_Fp, _Args...> _InvokePair;
        _InvokePair* __pp = new _InvokePair(std::forward<_Fp>(__f),
                                           std::forward<_Args>(__args)...);
        
        // 创建线程
        int __ec = __libcpp_thread_create(&__t_, &__thread_proxy<_Fp, _Args...>, __pp);
        if (__ec) {
            delete __pp;
            __throw_system_error(__ec, "thread constructor failed");
        }
    }
    
    // 移动构造函数
    _LIBCPP_INLINE_VISIBILITY
    thread(thread&& __t) noexcept : __t_(__t.__t_) {
        __t.__t_ = _LIBCPP_NULL_THREAD;
    }
    
    // 析构函数
    _LIBCPP_INLINE_VISIBILITY
    ~thread() {
        if (joinable())
            terminate();  // 如果线程仍可join，则终止程序
    }
    
    // 等待线程结束
    _LIBCPP_INLINE_VISIBILITY
    void join() {
        int __ec = __libcpp_thread_join(&__t_);
        if (__ec)
            __throw_system_error(__ec, "thread::join failed");
        __t_ = _LIBCPP_NULL_THREAD;
    }
    
    // 分离线程
    _LIBCPP_INLINE_VISIBILITY
    void detach() {
        int __ec = __libcpp_thread_detach(&__t_);
        if (__ec)
            __throw_system_error(__ec, "thread::detach failed");
        __t_ = _LIBCPP_NULL_THREAD;
    }
    
    // 检查线程是否可join
    _LIBCPP_INLINE_VISIBILITY
    bool joinable() const noexcept {
        return !__libcpp_thread_isnull(&__t_);
    }
    
    // 获取线程ID
    _LIBCPP_INLINE_VISIBILITY
    id get_id() const noexcept;
    
    // 获取原生句柄
    _LIBCPP_INLINE_VISIBILITY
    native_handle_type native_handle() { return __t_; }
    
    // 获取硬件并发数
    static unsigned hardware_concurrency() noexcept;
};
```


## 2. std::mutex 源码实现分析

### 2.1 实现概述

`std::mutex`是C++标准库中最基础的互斥锁实现。在LLVM libc++中，它通过平台抽象层封装了底层的pthread_mutex或其他平台特定的互斥锁实现
### 2.2 源码实现

```cpp
// mutex的核心实现方法
void mutex::lock() {
  // 调用平台抽象层的mutex锁定函数
  // __libcpp_mutex_lock是对pthread_mutex_lock的封装
  int ec = __libcpp_mutex_lock(&__m_);
  if (ec)
    // 如果锁定失败，抛出系统错误异常
    std::__throw_system_error(ec, "mutex lock failed");
}

bool mutex::try_lock() noexcept { 
  // 尝试锁定，不阻塞
  // 返回true表示成功获取锁，false表示锁已被占用
  return __libcpp_mutex_trylock(&__m_); 
}

void mutex::unlock() noexcept {
  // 释放锁
  int ec = __libcpp_mutex_unlock(&__m_);
  (void)ec;
  // 断言检查unlock操作是否成功
  _LIBCPP_ASSERT_VALID_EXTERNAL_API_CALL(
      ec == 0, "call to mutex::unlock failed. "
      "A possible reason is that the mutex wasn't locked");
}
```

### 1.3 关键设计要点

1. **错误处理**: `lock()`方法在失败时会抛出异常，而`try_lock()`和`unlock()`是noexcept的
2. **平台抽象**: 通过`__libcpp_mutex_*`函数族实现跨平台支持
3. **RAII支持**: 为配合RAII模式，提供了明确的锁定/解锁语义

## 2. std::lock_guard 源码实现分析

### 2.1 实现概述

`std::lock_guard`是一个RAII风格的锁管理器，在构造时自动获取锁，在析构时自动释放锁 。

### 2.2 源码实现

```cpp
template <class _Mutex>
class _LIBCPP_TEMPLATE_VIS lock_guard
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type& __m_;  // 持有mutex的引用

public:
    // 构造函数：获取锁
    _LIBCPP_INLINE_VISIBILITY
    explicit lock_guard(mutex_type& __m) : __m_(__m) {
        __m_.lock();  // 自动调用mutex的lock方法
    }
    
    // 采用已锁定的mutex构造（adopt_lock_t标记）
    _LIBCPP_INLINE_VISIBILITY
    lock_guard(mutex_type& __m, adopt_lock_t) noexcept : __m_(__m) {
        // 假设mutex已经被锁定，不再调用lock()
    }
    
    // 析构函数：释放锁
    _LIBCPP_INLINE_VISIBILITY
    ~lock_guard() {
        __m_.unlock();  // 自动调用mutex的unlock方法
    }

    // 禁止拷贝构造和赋值
    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
};
```


## 3. std::unique_lock 源码实现分析

### 3.1 实现概述

`std::unique_lock`提供了比`lock_guard`更灵活的锁管理功能，支持延迟锁定、条件锁定、手动解锁等操作 。

### 3.2 源码实现

```cpp
template <class _Mutex>
class _LIBCPP_TEMPLATE_VIS unique_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type* __m_;     // 指向mutex的指针
    bool        __owns_;  // 标记是否拥有锁

public:
    // 默认构造函数
    _LIBCPP_INLINE_VISIBILITY
    unique_lock() noexcept : __m_(nullptr), __owns_(false) {}
    
    // 构造并立即锁定
    _LIBCPP_INLINE_VISIBILITY
    explicit unique_lock(mutex_type& __m) : __m_(&__m), __owns_(true) {
        __m_->lock();
    }
    
    // 延迟锁定构造
    _LIBCPP_INLINE_VISIBILITY
    unique_lock(mutex_type& __m, defer_lock_t) noexcept
        : __m_(&__m), __owns_(false) {
        // 不立即锁定，等待后续调用lock()
    }
    
    // 尝试锁定构造
    _LIBCPP_INLINE_VISIBILITY
    unique_lock(mutex_type& __m, try_to_lock_t)
        : __m_(&__m), __owns_(__m.try_lock()) {
        // 尝试锁定，根据结果设置__owns_
    }
    
    // 接管已锁定的mutex
    _LIBCPP_INLINE_VISIBILITY
    unique_lock(mutex_type& __m, adopt_lock_t)
        : __m_(&__m), __owns_(true) {
        // 假设mutex已被锁定
    }
    
    // 移动构造函数
    _LIBCPP_INLINE_VISIBILITY
    unique_lock(unique_lock&& __u) noexcept
        : __m_(__u.__m_), __owns_(__u.__owns_) {
        __u.__m_ = nullptr;
        __u.__owns_ = false;
    }
    
    // 析构函数
    _LIBCPP_INLINE_VISIBILITY
    ~unique_lock() {
        if (__owns_)
            __m_->unlock();  // 只有拥有锁时才释放
    }
    
    // 手动锁定
    _LIBCPP_INLINE_VISIBILITY
    void lock() {
        if (__m_ == nullptr)
            __throw_system_error(EPERM, "unique_lock::lock: references null mutex");
        if (__owns_)
            __throw_system_error(EDEADLK, "unique_lock::lock: already locked");
        __m_->lock();
        __owns_ = true;
    }
    
    // 手动解锁
    _LIBCPP_INLINE_VISIBILITY
    void unlock() {
        if (!__owns_)
            __throw_system_error(EPERM, "unique_lock::unlock: not locked");
        __m_->unlock();
        __owns_ = false;
    }
    
    // 检查是否拥有锁
    _LIBCPP_INLINE_VISIBILITY
    bool owns_lock() const noexcept { return __owns_; }
    
    // 释放mutex的所有权（不解锁）
    _LIBCPP_INLINE_VISIBILITY
    mutex_type* release() noexcept {
        mutex_type* __m = __m_;
        __m_ = nullptr;
        __owns_ = false;
        return __m;
    }
};
```


## 4. std::condition_variable 源码实现分析

### 4.1 实现概述

`std::condition_variable`实现了条件变量，用于线程间的同步和通信。它必须与`std::unique_lock<std::mutex>`配合使用 。

### 4.2 源码实现

```cpp
class _LIBCPP_EXPORTED_FROM_ABI condition_variable
{
    __libcpp_condvar_t __cv_;  // 平台相关的条件变量实现

public:
    // 构造函数
    _LIBCPP_INLINE_VISIBILITY
    condition_variable() {
        // 初始化底层条件变量
        __libcpp_condvar_init(&__cv_);
    }
    
    // 析构函数
    ~condition_variable();
    
    // 禁止拷贝
    condition_variable(const condition_variable&) = delete;
    condition_variable& operator=(const condition_variable&) = delete;
    
    // 唤醒一个等待线程
    _LIBCPP_INLINE_VISIBILITY
    void notify_one() noexcept {
        __libcpp_condvar_signal(&__cv_);
    }
    
    // 唤醒所有等待线程
    _LIBCPP_INLINE_VISIBILITY
    void notify_all() noexcept {
        __libcpp_condvar_broadcast(&__cv_);
    }
    
    // 等待条件满足
    _LIBCPP_INLINE_VISIBILITY
    void wait(unique_lock<mutex>& __lk) {
        if (!__lk.owns_lock())
            __throw_system_error(EPERM, "condition_variable::wait: mutex not locked");
        // 调用底层等待函数，自动释放锁并等待信号
        int __ec = __libcpp_condvar_wait(&__cv_, __lk.mutex()->native_handle());
        if (__ec)
            __throw_system_error(__ec, "condition_variable wait failed");
    }
    
    // 带谓词的等待
    template <class _Predicate>
    _LIBCPP_INLINE_VISIBILITY
    void wait(unique_lock<mutex>& __lk, _Predicate __pred) {
        // 循环等待直到谓词返回true
        while (!__pred())
            wait(__lk);
    }
    
    // 超时等待
    template <class _Clock, class _Duration>
    cv_status
    wait_until(unique_lock<mutex>& __lk,
               const chrono::time_point<_Clock, _Duration>& __t) {
        if (!__lk.owns_lock())
            __throw_system_error(EPERM, "condition_variable::wait_until: mutex not locked");
        
        // 转换为系统时钟时间点
        typedef chrono::time_point<chrono::system_clock, chrono::nanoseconds> __sys_time_t;
        __sys_time_t __s_t = __to_sys_time(__t);
        
        // 调用底层超时等待函数
        int __ec = __libcpp_condvar_timedwait(&__cv_, __lk.mutex()->native_handle(), &__s_t);
        if (__ec != 0 && __ec != ETIMEDOUT)
            __throw_system_error(__ec, "condition_variable timed_wait failed");
        
        return __ec == ETIMEDOUT ? cv_status::timeout : cv_status::no_timeout;
    }
};
```

### 4.3 关键设计要点

1. **原子操作**: `wait()`操作原子性地释放锁并进入等待状态
2. **谓词支持**: 提供带谓词的等待，避免虚假唤醒问题
3. **超时机制**: 支持超时等待，防止无限期阻塞
4. **异常安全**: 在锁状态检查失败时抛出适当的异常


## 6. POSIX平台抽象层实现

### 6.1 实现概述

LLVM libc++通过`__threading_support`头文件提供了跨平台的线程抽象层，在POSIX系统上主要封装pthread API 。

### 6.2 类型定义和宏

```cpp
#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
// Mutex类型定义
typedef pthread_mutex_t __libcpp_mutex_t;
#define _LIBCPP_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER

// 递归mutex类型定义
typedef pthread_mutex_t __libcpp_recursive_mutex_t;

// 条件变量类型定义
typedef pthread_cond_t __libcpp_condvar_t;
#define _LIBCPP_CONDVAR_INITIALIZER PTHREAD_COND_INITIALIZER

// 执行一次标志
typedef pthread_once_t __libcpp_exec_once_flag;
#define _LIBCPP_EXEC_ONCE_INITIALIZER PTHREAD_ONCE_INIT

// 线程ID类型
typedef pthread_t __libcpp_thread_id;

// 线程句柄类型
#define _LIBCPP_NULL_THREAD 0U
typedef pthread_t __libcpp_thread_t;

// 线程局部存储键类型
typedef pthread_key_t __libcpp_tls_key;
#define _LIBCPP_TLS_DESTRUCTOR_CC

#endif // _LIBCPP_HAS_THREAD_API_PTHREAD
```

### 6.3 线程操作函数

```cpp
// 线程创建
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg) {
    return pthread_create(__t, nullptr, __func, __arg);
}

// 线程等待结束
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_thread_join(__libcpp_thread_t *__t) {
    return pthread_join(*__t, nullptr);
}

// 线程分离
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_thread_detach(__libcpp_thread_t *__t) {
    return pthread_detach(*__t);
}

// 检查线程句柄是否为空
_LIBCPP_THREAD_ABI_VISIBILITY
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
    return *__t == 0;
}

// 获取当前线程ID
_LIBCPP_THREAD_ABI_VISIBILITY
__libcpp_thread_id __libcpp_thread_get_current_id() {
    return pthread_self();
}

// 比较线程ID
_LIBCPP_THREAD_ABI_VISIBILITY
bool __libcpp_thread_id_equal(__libcpp_thread_id __lhs, __libcpp_thread_id __rhs) {
    return pthread_equal(__lhs, __rhs) != 0;
}

// 线程休眠
_LIBCPP_THREAD_ABI_VISIBILITY
void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns) {
    timespec __ts;
    __ts.tv_sec = static_cast<time_t>(__ns.count() / 1000000000);
    __ts.tv_nsec = static_cast<long>(__ns.count() % 1000000000);
    
    // 使用nanosleep实现精确休眠
    while (nanosleep(&__ts, &__ts) == -1 && errno == EINTR)
        ; // 处理信号中断，继续休眠剩余时间
}
```

### 6.4Mutex操作函数

```cpp
// Mutex初始化
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_mutex_init(__libcpp_mutex_t *__m) {
    // 使用默认属性初始化pthread_mutex
    return pthread_mutex_init(__m, nullptr);
}

// Mutex销毁
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m) {
    return pthread_mutex_destroy(__m);
}

// Mutex锁定
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_mutex_lock(__libcpp_mutex_t *__m) {
    return pthread_mutex_lock(__m);
}

// Mutex尝试锁定
_LIBCPP_THREAD_ABI_VISIBILITY
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m) {
    // pthread_mutex_trylock返回0表示成功
    return pthread_mutex_trylock(__m) == 0;
}

// Mutex解锁
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m) {
    return pthread_mutex_unlock(__m);
}

// 递归Mutex初始化
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m) {
    pthread_mutexattr_t attr;
    int __ec = pthread_mutexattr_init(&attr);
    if (__ec) return __ec;
    
    // 设置为递归类型
    __ec = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    if (__ec) {
        pthread_mutexattr_destroy(&attr);
        return __ec;
    }
    
    __ec = pthread_mutex_init(__m, &attr);
    pthread_mutexattr_destroy(&attr);
    return __ec;
}
```

### 6.5 条件变量操作函数

```cpp
// 条件变量初始化
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_init(__libcpp_condvar_t *__cv) {
    return pthread_cond_init(__cv, nullptr);
}

// 条件变量销毁
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv) {
    return pthread_cond_destroy(__cv);
}

// 条件变量信号通知（唤醒一个线程）
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_signal(__libcpp_condvar_t *__cv) {
    return pthread_cond_signal(__cv);
}

// 条件变量广播通知（唤醒所有线程）
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv) {
    return pthread_cond_broadcast(__cv);
}

// 条件变量等待
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m) {
    return pthread_cond_wait(__cv, __m);
}

// 条件变量超时等待
_LIBCPP_THREAD_ABI_VISIBILITY
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               timespec *__ts) {
    return pthread_cond_timedwait(__cv, __m, __ts);
}
```

