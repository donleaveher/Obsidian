## 1. 什么是协程
官方定义：是计算机程序的一类组件，推广了协作式多任务的子例程，允许执行被挂起与被恢复。
狭义定义：是一种可以在任意位置挂起和恢复执行的函数。
- **普通函数**：像看电影，从头看到尾，中间不能暂停
- **协程**：像看连续剧，可以看一集暂停，明天继续看下一集
协程让我们能够写出"看起来同步，实际异步"的代码，避免了回调地狱的问题。

## 2.C++20协程机制特点`<coroutine>`
- 语法角度：C++20协程机制是一种基于**概念约束**（Concepts）的泛型编程机制，编译器通过检查特定的类型要求来确定一个函数是否为协程。（满足特定类型以及接口，不满足直接报错)。
    C++20协程机制基于以下概念约束：
		-必须包含 `promise_type` 嵌套类型
		- `promise_type` 必须实现特定的接口（返回值，形参固定）
		- 协程操作符的调用对象（awaitable对象）必须实现特定的接口
```cpp
co_await Awaitable对象
```

- 采用的是无栈协程设计：
	-  堆上分配 ：协程状态存储在堆上的协程帧中，而非独立栈空间
	- 状态机实现 ：编译器将协程转换为状态机，每个挂起点对应一个状态

- C++20协程机制相比其他语言的协程，他更低级。用一句话总结C++20协程机制只提供协程机制（可暂停和恢复的机制），不提供任何调度和封装，用户需要自定义协程的所有相关行为，以及自定义协程的调度。
## 3. C++协程机制的三个关键字
重要**：函数中只要包含这三个关键字中的任何一个，该函数就被编译器识别为协程。
### `co_await`
暂停协程并等待某个操作完成：
```cpp
auto result = co_await async_operation();
// 协程在这里暂停，等待async_operation完成
// 完成后恢复执行，result获得返回值
```

### `co_yield`
产生一个值并暂停协程（用于生成器）：
```cpp
Generator<int> numbers() {
    for (int i = 0; i < 10; ++i) {
        co_yield i;  // 产生值i，然后暂停
    }
}
```

### `co_return`
从协程返回值并结束协程：
```cpp
Task<int> compute() {
    co_return 42;  // 返回42并结束协程
}
```

**

## 4. C++协程机制的三个核心组件
###  (1)  std::coroutine_handle（协程句柄）
协程句柄是C++20协程机制的核心组件之一，它提供了对协程状态的底层控制接口。通过协程句柄我们可以恢复暂停的协程，销毁协程
，访问协程的promise对象，查看协程的状态。
### (2) Promise对象-promise_type （协程控制器 ）
**功能**：控制协程的生命周期，管理协程的状态转换和值传递。
`promise_type` 就像协程的"管理员"，管理协程初始和结束的状态，管理协程的数据传递，管理协程的异常处理。
### (3) awaitable（可等待对象）
**功能**：定义协程在 `co_await`挂起 时的行为，决定是否暂停以及暂停时发生什么行为，以及恢复时发生什么行为。C++标准库提供了两个现成的awaitable对象：std::suspend_always和std::suspend_never
```cpp
co_await Awaitable对象
```

## 5. std::coroutine_handle详解

协程句柄是C++20协程的核心组件之一，它提供了对协程状态的底层控制接口。`std::coroutine_handle` 是一个轻量级的句柄类型，用于管理和操作协程的执行状态。出现异常。
### 协程句柄的主要接口

#### 基本状态查询

```cpp
// 检查协程是否已完成
bool done() const noexcept;

```

#### 协程控制操作

```cpp
// 恢复协程执行
void resume();

// 销毁协程
void destroy();
```

#### Promise对象（promise_type类）访问

```cpp
// 访问协程的promise对象（仅限类型化句柄）
Promise& promise() const;
```

#### 句柄创建和转换

```cpp
// 从promise对象创建句柄
static coroutine_handle from_promise(Promise& p);

// 从地址创建句柄
static coroutine_handle from_address(void* addr);
```


## 6、Promise Type接口

promise_type是协程返回类型必须定义的嵌套类型，控制协程的生命周期和行为。

| 接口方法                    | 是否必需 | 功能描述                                                 |
| ----------------------- | ---- | ---------------------------------------------------- |
| `get_return_object()`   | 必需   | 创建并返回协程对象，通常返回协程句柄或包装类                               |
| `initial_suspend()`     | 必需   | 控制协程启动时的挂起行为，返回awaitable对象                           |
| `final_suspend()`       | 必需   | 控制协程结束时的挂起行为，返回awaitable对象，通常返回`std::suspend_always` |
| `unhandled_exception()` | 必需   | 处理协程中未捕获的异常，通常调用`std::current_exception()`           |
| `return_void()`         | 可选   | 处理无返回值的协程结束，与`return_value()`互斥                      |
| `return_value(T)`       | 可选   | 处理有返回值的协程结束，与`return_void()`互斥                       |
| `yield_value(T)`        | 可选   | 处理`co_yield`表达式，返回awaitable对象                        |
| `await_transform(T)`    | 可选   | 转换`co_await`表达式的操作数，自定义awaitable行为                   |
### 1. 必需的接口方法

#### `get_return_object()`
```cpp
ReturnType get_return_object();
```
- **作用**：创建并返回协程的返回对象
- **调用时机**：协程开始执行前
- **实现**：通常返回包含协程句柄的对象

#### `initial_suspend()`
```cpp
auto initial_suspend() noexcept;
```
- **作用**：决定协程开始时是否挂起
- **返回值**：awaitable对象
- **常见选择**：
  - `std::suspend_always{}`：协程开始时挂起（惰性启动）
  - `std::suspend_never{}`：协程立即开始执行（急切启动）

#### `final_suspend()`
```cpp
auto final_suspend() noexcept;
```
- **作用**：决定协程结束时的行为
- **返回值**：awaitable对象
- **常见选择**：
  - `std::suspend_always{}`：协程结束时挂起，保持存活
  - `std::suspend_never{}`：协程结束时立即销毁
  - 自定义awaiter：实现特定的结束逻辑

#### `unhandled_exception()`
```cpp
void unhandled_exception();
```
- **作用**：处理协程中未捕获的异常
- **调用时机**：协程抛出未捕获异常时
- **常见实现**：保存异常指针或重新抛出

### 2. 返回值处理接口（二选一）

#### `return_value(T value)`
```cpp
void return_value(T value);
```
- **用于**：有返回值的协程（`co_return value`）
- **作用**：保存协程的返回值

#### `return_void()`
```cpp
void return_void();
```
- **用于**：无返回值的协程（`co_return;`或函数末尾）
- **作用**：标记协程正常结束

### 3. 可选的接口方法

#### `yield_value(T value)`
```cpp
auto yield_value(T value);
```
- **用于**：支持`co_yield`的协程
- **返回值**：awaitable对象
- **作用**：处理生成器模式的值产出

#### `await_transform(Awaitable&& awaitable)`
```cpp
auto await_transform(Awaitable&& awaitable);
```
- **作用**：转换`co_await`表达式的操作数
- **用途**：自定义awaitable对象的行为
- **返回值**：转换后的awaitable对象


## 7、Awaitable接口

awaitable接口定义了可以被`co_await`的对象的行为。

| 接口方法 | 是否必需 | 功能描述 |
|---------|---------|----------|
| `await_ready()` | 必需 | 检查操作是否已完成，返回`bool`。若返回`true`则不挂起协程 |
| `await_suspend(handle)` | 必需 | 协程挂起时调用，接收协程句柄。可返回`void`、`bool`或另一个协程句柄 |
| `await_resume()` | 必需 | 协程恢复时调用，返回`co_await`表达式的结果值 |

### 1. 核心接口方法

#### `await_ready()`
```cpp
bool await_ready() const noexcept;
```
- **作用**：检查awaitable对象是否已经准备好，可以立即返回结果
- **返回值**：
  - `true`：立即可用，不挂起协程，直接调用`await_resume()`
  - `false`：需要挂起协程，调用`await_suspend()`
- **优化作用**：避免不必要的协程挂起和上下文切换

#### `await_suspend()`
```cpp
// 三种可能的签名
void await_suspend(std::coroutine_handle<> h) noexcept;
bool await_suspend(std::coroutine_handle<> h) noexcept;
std::coroutine_handle<> await_suspend(std::coroutine_handle<> h) noexcept;
```

- **调用时机**：当`await_ready()`返回`false`时
- **参数**：当前被挂起的协程句柄
- **作用**：处理协程挂起逻辑，启动异步操作

当执行 co_await awaitable_object 时：
```cpp
Task caller_coroutine() {
    // caller_coroutine是当前执行的协程
    auto result = co_await some_awaitable;  // 这里
    // ...
}
```
在这个场景中：
- await_suspendd的形参 是  caller_coroutine 的协程句柄
- some_awaitable ：被等待的awaitable对象（不是协程）
- 调用时机 ：当 some_awaitable.await_ready() 返回 false 时
##### 返回值类型详解：
**1. `void`返回值**：
- **含义**：协程被挂起，需要外部代码手动恢复
- **行为**：协程保持挂起状态，直到某处调用`handle.resume()`
- **使用场景**：异步I/O操作、定时器、事件等待
- **特点**：最常见的形式，给予最大的控制灵活性

**2. `bool`返回值**：
- **含义**：根据返回值决定协程是否保持挂起
- **行为**：
  - 返回`true`：协程保持挂起状态
  - 返回`false`：立即恢复协程执行
- **使用场景**：条件性挂起，运行时决定是否需要等待
- **特点**：提供动态的挂起控制

**3. `std::coroutine_handle<>`返回值**：
- **含义**：挂起当前协程，立即恢复指定的协程
- **行为**：编译器自动调用返回句柄的`resume()`方法
- **使用场景**：协程间的直接切换、对称协程
- **特点**：实现零开销的协程切换

#### `await_resume()`
```cpp
T await_resume();
```
- **作用**：协程恢复时获取`co_await`表达式的结果
- **调用时机**：
  - `await_ready()`返回`true`时立即调用
  - 协程从挂起状态恢复时调用
- **返回值**：`co_await`表达式的值
- **异常处理**：可以抛出异常来传播错误

### 2. 标准库提供的awaitable对象

#### `std::suspend_always`
```cpp
struct suspend_always {
    constexpr bool await_ready() const noexcept { return false; }
    constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
    constexpr void await_resume() const noexcept {}
};
```
- **用途**：总是挂起协程
- **应用场景**：`initial_suspend()`、`final_suspend()`

#### `std::suspend_never`
```cpp
struct suspend_never {
    constexpr bool await_ready() const noexcept { return true; }
    constexpr void await_suspend(std::coroutine_handle<>) const noexcept {}
    constexpr void await_resume() const noexcept {}
};
```
- **用途**：从不挂起协程
- **应用场景**：立即执行的协程

## 8、协程执行流程

### 协程生命周期

1. **分配协程帧**：在堆上分配存储空间
2. **构造promise对象**：创建promise_type实例
3. **调用get_return_object()**：创建返回对象
4. **调用initial_suspend()**：决定是否立即开始
5. **执行协程体**：运行用户代码
6. **处理返回值**：调用return_value()或return_void()
7. **调用final_suspend()**：决定结束行为
8. **销毁局部变量**：清理协程内的对象
9. **销毁promise对象**：清理promise实例
10. **释放协程帧**：回收内存

### co_await表达式的执行步骤

1. **获取awaitable对象**（按优先级查找）
2. **调用`await_ready()`**：检查是否立即可用
3. **条件分支**：
   - 如果`true`：直接调用`await_resume()`
   - 如果`false`：挂起协程并调用`await_suspend()`
4. **处理挂起结果**（仅当`await_ready()`返回`false`时）：
   - `void`：等待外部恢复
   - `bool`：根据返回值决定是否保持挂起
   - `handle`：立即恢复指定协程
5. **协程恢复时调用`await_resume()`**：获取最终结果

## 9.语法总结
构建一个C++20协程(可以任务是在构建满足要求的函数)，必须需要满足以下三点：
- 1.返回值类型带有promise_type类型 (必须名字一样)
- 2.必须具有至少co_await co_yield和co_return 三个关键字的其中一种
- 3.如果使用了co_await co_yield和co_return 三个关键字的其中一种，就必须要实现promise_type必须要实现的接口。

co_await的调用对象必须实现awaitable接口。

注意promise_type和awaitable不是一个概念并且不冲突，一个返回值值类可以同时拥有promise_type和awaitable，但是promise_type是构建协程的必要条件，而awaitable是使用co_await调用对象的必要条件。

## 10. 完整示例代码

### 基础任务协程

```cpp
#include <coroutine>
#include <exception>
#include <iostream>
// 协程返回值类型
class Task {
 public:
  // 必须具有promise_type类型
  struct promise_type {
    Task get_return_object() {
      std::cout << "返回对象\n";
      return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
    }
    // 设置协程初始是挂起状态
    std::suspend_always initial_suspend() {
      std::cout << "协程初始挂起\n";
      return {};
    }
    // 设置最后是挂起状态
    // 如果你想在类的析构函数里销毁句柄，不要设置成非挂起状态
    // 因为设置成非挂起状态，协程句柄销毁的时间比你类销毁时间早，协程完成后句柄就自动销毁了，你再析构函数使用句柄就会是访问野指针
    std::suspend_always final_suspend() noexcept { return {}; }
    // 无返回值
    void return_void() {}
    void unhandled_exception() { std::terminate(); }
  };

 public:
  Task(std::coroutine_handle<promise_type> h) : handle(h) {}

  ~Task() {
    if (handle) {
      handle.destroy();
    }
  }

  bool resume() {
    // 如果协程还存在并且还没有完成
    if (handle && !handle.done()) {
      handle.resume();
      return true;
    }
    return false;
  }

 private:
  std::coroutine_handle<promise_type> handle;  // 定义一个协程句柄
};

// 协程
Task simple_coroutine() {
  std::cout << "协程开始...\n";
  co_await std::suspend_always{};
  std::cout << "协程继续...\n";
  co_return;
}

int main() {
  std::cout << "获取到协程句柄\n";
  Task h = simple_coroutine();
  // 直到resume返回false,也就是协程完成，退出循环
  while (h.resume());
  std::cout << "协程结束\n";
  return 0;
}
```

### awaitable的协程返回值类型
```cpp
#include <coroutine>
#include <exception>
#include <iostream>

// 协程返回值类型
class Task {
 public:
  // 必须具有promise_type类型
  struct promise_type {
    Task get_return_object() {
      // std::cout << "返回协程返回值对象\n";
      return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
    }
    // 设置协程初始是非挂起状态
    std::suspend_never initial_suspend() {
      // std::cout << "协程初始挂起\n";
      return {};
    }
    // 设置最后是挂起状态
    std::suspend_always final_suspend() noexcept { return {}; }
    // 无返回值
    void return_void() {}
    void unhandled_exception() { std::terminate(); }
  };

  // 实现awaitable对象的三个接口
 public:
  // 默认挂起
  bool await_ready() const noexcept { return false; }

  // 立即恢复当前协程
  bool await_suspend(std::coroutine_handle<> awaiting_coroutine) noexcept {
    std::cout << "协程挂起时执行逻辑\n";
    return false;
  }

  // 当协程恢复时的返回值
  void await_resume() noexcept { std::cout << "协程恢复时执行逻辑\n"; }

 public:
  Task(std::coroutine_handle<promise_type> h) : handle(h) {}

  ~Task() {
    if (handle) {
      handle.destroy();
    }
  }

  bool resume() {
    // 如果协程还存在并且还没有完成
    if (handle && !handle.done()) {
      handle.resume();
      return true;
    }
    return false;
  }

 private:
  std::coroutine_handle<promise_type> handle;
};

Task coro() {
  std::cout << "coro 2执行...\n";
  co_return;
}

// 协程
/*
co_await执行顺序:
1.调用 coro() → 创建协程并执行完成
2.co_await 表达式开始
3.await_ready() 返回 false
4.挂起 simple_coroutine
5.await_suspend() 返回 false
6.立即恢复 simple_coroutine
7.await_resume() 执行
8.继续执行后续代码
*/
Task simple_coroutine() {
  std::cout << "协程开始...\n";
  co_await coro();
  std::cout << "协程结束...\n";
  co_return;
}

int main() {
  Task h = simple_coroutine();
  return 0;
}
```

### 单独awaitable对象
```cpp
#include <coroutine>
#include <exception>
#include <iostream>

// 协程返回值类型
class Task {
 public:
  // 必须具有promise_type类型
  struct promise_type {
    Task get_return_object() {
      // std::cout << "返回协程返回值对象\n";
      return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
    }
    // 设置协程初始是挂起状态
    std::suspend_always initial_suspend() {
      // std::cout << "协程初始挂起\n";
      return {};
    }
    // 设置最后是挂起状态
    std::suspend_always final_suspend() noexcept { return {}; }
    // 无返回值
    void return_void() {}
    void unhandled_exception() { std::terminate(); }
  };

  // 实现awaitable对象的三个接口
 public:
 public:
  Task(std::coroutine_handle<promise_type> h) : handle(h) {}

  ~Task() {
    if (handle) {
      handle.destroy();
    }
  }

  bool resume() {
    // 如果协程还存在并且还没有完成
    if (handle && !handle.done()) {
      handle.resume();
      return true;
    }
    return false;
  }

 private:
  std::coroutine_handle<promise_type> handle;
};

// 自定义awaitable对象，挂起时设置值，恢复的时候输出值
struct myawaiter {
  bool await_ready() const noexcept { return false; }

  void await_suspend(std::coroutine_handle<> awaiting_coroutine) noexcept {
    std::cout << "协程挂起时执行逻辑\n";
    value_ = 1;
  }

  void await_resume() noexcept {
    std::cout << "协程恢复时执行逻辑\n";
    std::cout << "value_ : " << value_ << std::endl;
  }

  int value_;
};

// 协程
Task simple_coroutine() {
  std::cout << "协程开始...\n";
  co_await myawaiter{};
  std::cout << "协程结束...\n";
  co_return;
}

int main() {
  Task h = simple_coroutine();
  // 直到resume返回false,也就是协程完成，退出循环
  while (h.resume());
  return 0;
}
```

### 生成器协程 （co_yield关键字使用）

```cpp
#include <coroutine>
#include <iostream>
#include <exception>
// 生成器类型
template<typename T>
struct Generator {
    struct promise_type {
        T current_value;
        
        Generator get_return_object() {
            return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        
        std::suspend_always yield_value(T value) {
            current_value = value;
            return {};
        }
        
        void return_void() {}
        void unhandled_exception() { std::terminate(); }
    };
    
    std::coroutine_handle<promise_type> handle;
    
    Generator(std::coroutine_handle<promise_type> h) : handle(h) {}
    
    ~Generator() {
        if (handle) handle.destroy();
    }
      
    bool next() {
        if (!handle || handle.done()) return false;
        handle.resume();
        return !handle.done();
    }
    
    T value() const {
        return handle.promise().current_value;
    }
};

// 斐波那契生成器
Generator<int> fibonacci(int count) {
    int a = 0, b = 1;
    
    for (int i = 0; i < count; ++i) {
        co_yield a;
        int temp = a + b;
        a = b;
        b = temp;
    }
}

int main() {  
    // 斐波那契数列
    std::cout << "斐波那契数列前10项: ";
    auto fib = fibonacci(10);
    while (fib.next()) {
        std::cout << fib.value() << " ";
    }
    std::cout << "\n";
 
    return 0;
}
```

### 带返回值的协程

```cpp
#include <coroutine>
#include <exception>
#include <iostream>

// 协程返回值类型
template <class T>
class Task {
 public:
  // 必须具有promise_type类型
  struct promise_type {
    Task get_return_object() {
      // std::cout << "返回协程返回值对象\n";
      return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
    }
    // 设置协程初始是挂起状态
    std::suspend_always initial_suspend() {
      // std::cout << "协程初始挂起\n";
      return {};
    }
    // 设置最后是挂起状态
    std::suspend_always final_suspend() noexcept { return {}; }
    // 返回值
    void return_value(T val) { value_ = val; }
    void unhandled_exception() { std::terminate(); }
    T value_;  // 存储返回值
  };

 public:
  Task(std::coroutine_handle<promise_type> h) : handle(h) {}

  ~Task() {
    if (handle && !handle.done()) {
      handle.destroy();
    }
  }

  bool resume() {
    // 如果协程还存在并且还没有完成
    if (handle && !handle.done()) {
      handle.resume();
      return true;
    }
    return false;
  }

  // 获取协程返回值
  T get_result() {
    if (!handle) {
      throw std::runtime_error("Invalid coroutine handle");
    }

    // 确保协程已经完成
    if (!handle.done()) {
      return {};
    }

    return handle.promise().value_;
  }

 private:
  T result_;
  std::coroutine_handle<promise_type> handle;
};

// 协程
Task<int> simple_coroutine2() { co_return 10; }

int main() {
  Task h = simple_coroutine2();

  while (h.resume());
  std::cout << "协程返回值：" << h.get_result() << std::endl;
  return 0;
  }
